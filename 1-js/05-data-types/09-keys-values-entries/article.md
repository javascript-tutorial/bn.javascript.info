
# Object.keys, values, entries

চলুন প্রতিটি ডাটা স্ট্রাকচার এবং তাদের ইটারেশন নিয়ে আরো কিছু ব্যাপার জানা যাক।

পূর্বের অধ্যায়ে আমরা `map.keys()`, `map.values()`, `map.entries()` মেথডসমূহ দেখেছি।

এইগুলো জেনেরিক মেথড, অর্থাৎ প্রতিটি ডাটা স্ট্রাকচারের কমন মেথড। যদি আমরা আমাদের নিজস্ব কোন ডাটা স্ট্রাকচারও তৈরি করি তাহলে ঐ ডাটা স্ট্রাকচারেও এই মেথডগুলো ইপ্লিমেন্ট করা উচিত।

নিচের ডাটা স্ট্রাকচারগুলোতেও মেথডগুলো আছে:

- `Map`
- `Set`
- `Array`

অবজেক্টেও মেথডগুলো আছে, তবে এর সিনট্যাক্স কিছুটা ভিন্ন।

## Object.keys, values, entries

অবজেক্টের মেথডসমূহ হল:

- [Object.keys(obj)](mdn:js/Object/keys) -- কী এর অ্যারে।
- [Object.values(obj)](mdn:js/Object/values) -- ভ্যালু এর অ্যারে।
- [Object.entries(obj)](mdn:js/Object/entries) -- `[key, value]` যুক্ত অ্যারে।

এখানে `Map` এর সাথে `Object` এর মেথডসমূহের পার্থক্য দেখানো হল:

|             | Map              | Object       |
|-------------|------------------|--------------|
| সিনট্যাক্স | `map.keys()`  | `obj.keys()` নই `Object.keys(obj)` |
| Return ভ্যালু     | Iterable    | Array                     |

প্রথম পার্থক্যটি আমরা দেখেছি অন্যান্য ডাটা স্ট্রাকচারের মত `obj.keys()` এর বদলে `Object.keys(obj)` কল করছি।

এমন কেন? প্রধান কারণ হল সহজযোগ্য করা। কেননা জাভাস্ক্রিপ্টের যে কোন ডাটা স্ট্রাকচার অবজেক্টের উপর ভিত্তি করে তৈরি হয়। তাই আমরা আমাদের নিজস্ব ডাটা স্ট্রাকচারের জন্য `data.values()` মেথড ইমপ্লিমেন্ট করতে পারি। এবং আমরা চাইলে আমাদের বেস অবজেক্টকেও কল করতে পারব`Object.values(data)`।

দ্বিতীয় পার্থক্যটি হল `Object.*` এর মেথডগুলো অ্যারে রিটার্ন করে।

যেমন:

```js
let user = {
  name: "John",
  age: 30
};
```

- `Object.keys(user) = ["name", "age"]`
- `Object.values(user) = ["John", 30]`
- `Object.entries(user) = [ ["name","John"], ["age",30] ]`

নিচের উদাহরণে, আমরা `Object.values` এর সাহায্যে প্রপার্টিগুলোর ভ্যালু অ্যাক্সেস করি:

```js run
let user = {
  name: "John",
  age: 30
};

// loop over values
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
```

```warn header="Object.keys/values/entries` মেথড `Symbol(...)` দ্বারা ডিক্লেয়ার প্রপার্টিগুলো ইগনোর করে"
`for..in` লুপের মত মেথডগুলো `Symbol(...)` দ্বারা ডিক্লেয়ার প্রপার্টিগুলোকে অ্যাক্সেস করে না।

এটিই সুবিধাজনক। তবে যদি আমাদের সিম্বলিক প্রপার্টি সমূহ লাগে, তাহলে এর জন্য আরেকটি বিশেষ মেথড আছে [Object.getOwnPropertySymbols](mdn:js/Object/getOwnPropertySymbols) যা শুধুমাত্র সিম্বলিক প্রপার্টিগুলো অ্যারে আকারে রিটার্ন করে। এবং সকল প্রপার্টির জন্য আরেকটি [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) মেথড আছে।
```


## অবজেক্টকে পরিবর্তন

অ্যারের অনেক মেথড আছে যা অবজেক্টে নেই, যেমন `map`, `filter` ইত্যাদি।

যদি আমরা সেসব মেথড ব্যবহার করতে চাই তাহলে `Object.fromEntries` এ `Object.entries` ব্যবহারের মাধ্যমে করতে পারি:

1. `obj` এর মান গুলোকে কী/ভ্যালু অ্যারে হিসেবে পেতে `Object.entries(obj)` কল করি।
2. এখন ঐ অ্যারেতে মেথডগুলো ব্যবহার করতে পারি, যেমন `map`।
3. এখন রিটার্নকৃত অ্যারেকে অবজেক্টে রূপান্তর করতে `Object.fromEntries(array)` কল করি।

নিচের উদাহরণটি দেখুন:

```js run
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

*!*
// prices কে অ্যারেতে কনভার্ট করে তার মধ্যে map অপারেশন চালিয়ে কী/ভ্যালু অ্যারেটিকে অবজেক্টে রূপান্তর
let doublePrices = Object.fromEntries(
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);
*/!*

alert(doublePrices.meat); // 8
```

প্রথমে এটি দুর্বোধ্য লাগতে পারে, তবে কয়েকবার ব্যবহার করলে আপনি সহজেই এটি বুঝে যাবেন। এভাবে আমরা অবজেক্টেও বিভিন্ন ধরণের অপারেশন চালাতে পারি।
