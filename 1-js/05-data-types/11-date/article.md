# তারিখ এবং সময়

এই অধ্যায়ে আমরা নতুন আরেকটি বিল্ট-ইন অবজেক্ট [Date](mdn:js/Date) সম্পর্কে জানব। এর সাহায্যে আমরা তারিখ/সময় এর বিভিন্ন মেথড নিয়ে কাজ করতে পারি।

যেমন, আমরা কোন ডাটা তৈরির বা পরিবর্তন এর সময় সংরক্ষণ করতে, অথবা বর্তমান সময় বা তারিখ জানার জন্য এদের ব্যবহার করি।

## অবজেক্ট তৈরি

নতুন একটি `Date` অবজেক্ট তৈরি করতে আমরা `new Date()` কে কল করব, যেটি কিছু আর্গুমেন্ট নেয়:

`new Date()`
: কোন আর্গুমেন্ট ছাড়া `Date` অবজেক্ট কল করলে এটি বর্তমান সময় এবং তারিখ দেখাবে:

    ```js run
    let now = new Date();
    alert( now ); // বর্তমান সময় এবং তারিখ দেখাবে
    ```

`new Date(milliseconds)`
: `Date` অবজেক্ট তৈরির সময় আমরা মিলিসেকেন্ড(১ সেকেন্ডের ১০০০ ভাগ) আর্গুমেন্ট হিসেবে পাঠাতে পারি, যা ১৯৭০ সালের ১লা জানুয়ারি(UTC+0) থেকে সময় গণনা করে।

    ```js run
    // ০ দ্বারা বুঝায় 01.01.1970 UTC+0
    let Jan01_1970 = new Date(0);
    alert( Jan01_1970 );

    // এখন আরো ২৪ ঘন্টা যোগ করলে পাই, 02.01.1970 UTC+0
    let Jan02_1970 = new Date(24 * 3600 * 1000);
    alert( Jan02_1970 );
    ```

    ১৯৭০ এর শুরু থেকে অতিক্রান্ত সময়কে মিলিসেকেন্ড দ্বারা প্রকাশ করাকে বলা হয় *timestamp*।

    কোন একটি তারিখকে আমরা এভাবে সংখ্যা দ্বারা প্রকাশ করতে পারি। `new Date(timestamp)` অবজেক্ট তৈরিতে আমরা সর্বদা কোন একটি টাইমস্ট্যাম্প আর্গুমেন্ট হিসেবে পাঠাব যা আমাদের ঐ টাইমস্ট্যাম্প হিসেবে `Date` অবজেক্ট রিটার্ন করে এবং `Date` অবজেক্ট থেকে টাইমস্ট্যাম্প পেতে আমরা `date.getTime()` মেথড ব্যবহার করতে পারি (নিম্নে বিস্তারিত আলোচনা করা হয়েছে)।

    ০১-০১-১৯৭০ এর আগের তারিখের জন্য আমরা ঋণাত্নক টাইমস্ট্যাম্প ব্যবহার করতে পারি, যেমন:
    ```js run
    // 31 Dec 1969
    let Dec31_1969 = new Date(-24 * 3600 * 1000);
    alert( Dec31_1969 );
    ```

`new Date(datestring)`
: যদি প্রথম একটি আর্গুমেন্টে কোন একটি তারিখ স্ট্রিং হিসেবে পাঠাই, তাহলে এটি স্বয়ংক্রিয়ভাবে তারিখে রূপান্তর হয়ে যায়। এক্ষেত্রে `Date.parse` অ্যালগরিদম ব্যবহার হয়(নিম্নে বিস্তারিত আলোচনা করা হয়েছে)।

    ```js run
    let date = new Date("2017-01-26");
    alert(date);
    // যেহেতু কোন সময়ের উল্লেখ নেই, সুতরাং এটি GMT রাত ১২.০০ টা হিসেব করে নেয়
    // এবং স্থানীয় সময়মান অনুসারে দেখায়
    // সময়টি হতে পারে
    // Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)
    // অথবা
    // Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)
    // অথবা
    // Thu Jan 26 2017 06:00:00 GMT+0600 (Bangladesh Standard Time)
    ```

`new Date(year, month, date, hours, minutes, seconds, ms)`
: স্থানীয় সময়মান হিসেবে `Date` অবজেক্ট তৈরীর জন্য আমরা উপরের নিয়ম অনুযায়ী কল করতে পারি, এক্ষেত্রে প্রথম দুটি আর্গুমেন্ট অবশ্যই দিতে হবে, শুধুমাত্র একটি আর্গুমেন্ট পাঠালে তখন এটি টাইমস্ট্যাম্প হিসেবে ধরে নিবে।

    - `year` অবশ্যই পূর্ণভাবে লিখতে হবে: `1998` এর বদলে `98` লিখা সঠিক নয়।
    - `month` `0` (Jan) থেকে শুরু হয়, সর্বোচ্চ `11` (Dec)।
    - `date` প্যারামিটার মাসের দিন হিসেব করে, যদি আর্গুমেন্ট পাস করা না হয় ডিফল্ট `1` তারিখ সেট হয়।
    - যদি আর্গুমেন্ট `hours/minutes/seconds/ms` পাস করা না হয় ডিফল্ট `0` সেট হয়।

    উদাহরণস্বরূপ:

    ```js
    new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
    new Date(2011, 0, 1); // দুইটার মান একই
    ```

    সর্বাধিক নির্ভুল মান পেতে 1ms (1/1000 sec) ব্যবহার করা যায়:

    ```js run
    let date = new Date(2011, 0, 1, 2, 3, 4, 567);
    alert( date ); // 1.01.2011, 02:03:04.567
    ```

## তারিখের বিভিন্ন মেথড

`Date` অবজেক্ট এর তারিখ, মাস, সময় ইত্যাদি জানার জন্য বিভিন্ন বিল্ট-ইন মেথড রয়েছে:

[getFullYear()](mdn:js/Date/getFullYear)
: এটি সাল রিটার্ন করে (৪ অঙ্কের)

[getMonth()](mdn:js/Date/getMonth)
: এটি মাসের ক্রম রিটার্ন করে, **0 হতে 11 পর্যন্ত**

[getDate()](mdn:js/Date/getDate)
: এটি মাসের কততম দিন তা রিটার্ন করে, 1 হতে 31 পর্যন্ত, যদিও এই মেথডের নামটি কিছুটা সাংঘর্ষিক মনে হয়।

[getHours()](mdn:js/Date/getHours), [getMinutes()](mdn:js/Date/getMinutes), [getSeconds()](mdn:js/Date/getSeconds), [getMilliseconds()](mdn:js/Date/getMilliseconds)
: ঘন্টা, মিনিট, সেকেন্ড, মিলিসেকেন্ড ইত্যাদি রিটার্ন করে।

```warn header="`getYear()` নয়, বরং `getFullYear()`"
অনেক জাভাস্ক্রিপ্ট ইঞ্জিন একটি নন-স্ট্যান্ডার্ড মেথড `getYear()` সাপোর্ট করে, তবে এটি বর্তমানে অচল। এটি অনেক সময় ২ অঙ্কের সাল রিটার্ন করে, দয়া করে এটি ব্যবহার করবেন না। তার পরিবর্তে `getFullYear()` ব্যবহার করুন।
```

এছাড়াও, আমরা সপ্তাহের নামও জানতে পারি:

[getDay()](mdn:js/Date/getDay)
: এটি বারের নাম রিটার্ন করে, `0` (Sunday বা রবিবার) হতে `6` (Saturday বা শনিবার), যদিও অনেক দেশে সপ্তাহের শুরু অন্য কোন দিন দিয়ে হয়, এক্ষেত্রে আপনাকে নিজস্ব মেথড ব্যবহার করতে হতে পারে যেমন: বাংলাদেশ।

**উপরে উল্লেখিত সকল মেথড স্থানীয় সময় এর উপর ভিত্তি করে মান রিটার্ন করে।**

এছাড়াও আমরা চাইলে UTC হিসেবে মান পেতে পারি, যা UTC+0 সময় অনুযায়ী তারিখ, সময় ও দিন রিটার্ন করে: [getUTCFullYear()](mdn:js/Date/getUTCFullYear), [getUTCMonth()](mdn:js/Date/getUTCMonth), [getUTCDay()](mdn:js/Date/getUTCDay)। এক্ষেত্রে `"get"` এর পর `"UTC"` যোগ করলেই হবে।

UTC এর সময় অনুযায়ী আপনার স্থানীয় সময় পরিবর্তন হলে, নিচের কোডের জন্য আলাদা আলাদা মান দেখাবে:

```js run
// current date
let date = new Date();

// স্থানীয় সময় অনুযায়ী দেখাবে
alert( date.getHours() );

// UTC+0 এর সময় অনুযায়ী দেখাবে (লন্ডনের সময়)
alert( date.getUTCHours() );
```

উপরে উল্লেখিত মেথড গুলো ছাড়া আরো দুটি বিশেষ মেথড আছে যাদের আলাদা করে UTC মেথড নাই:

[getTime()](mdn:js/Date/getTime)
: ঐ তারিখের টাইমস্ট্যাম্প রিটার্ন করবে -- অর্থাৎ ১লা জানুয়ারী ১৯৭০ এর ০০.০০ (UTC+0) হতে অতিক্রান্ত মিলিসেকেন্ড।

[getTimezoneOffset()](mdn:js/Date/getTimezoneOffset)
: UTC+0 এবং স্থানীয় সময়ের পার্থক্য মিনেটের মধ্যে দেখাবে:

    ```js run
    // যদি আপনার স্থানীয় সময় UTC-1 অনুযায়ী হয় দেখাবে 60
    // যদি আপনার স্থানীয় সময় UTC+3 অনুযায়ী হয় দেখাবে -180
    // বাংলাদেশের জন্য দেখাবে UTC+6 অনুযায়ী -360
    alert( new Date().getTimezoneOffset() );

    ```

## সময়ের বিভিন্ন অংশ সেট করা

নিচের মেথড গুলোর সাহায্যে আমরা সময়ের বিভিন্ন প্রপার্টি সেট করতে পারব:

- [`setFullYear(year, [month], [date])`](mdn:js/Date/setFullYear)
- [`setMonth(month, [date])`](mdn:js/Date/setMonth)
- [`setDate(date)`](mdn:js/Date/setDate)
- [`setHours(hour, [min], [sec], [ms])`](mdn:js/Date/setHours)
- [`setMinutes(min, [sec], [ms])`](mdn:js/Date/setMinutes)
- [`setSeconds(sec, [ms])`](mdn:js/Date/setSeconds)
- [`setMilliseconds(ms)`](mdn:js/Date/setMilliseconds)
- [`setTime(milliseconds)`](mdn:js/Date/setTime) (sets the whole date by milliseconds since 01.01.1970 UTC)

`setTime()` ব্যতীত সকল মেথডের আরো একটি UTC মেথড আছে, যেমন: `setUTCHours()`.

আমরা দেখছি, কিছু মেথড আছে যারা বিভিন্ন মান একসাথে নিতে পারে, যেমন `setHours`। এক্ষেত্রে শুধুমাত্র আর্গুমেন্ট পাঠানো অংশটুকুই পরিবর্তন হবে, বাকীগুলো হবে না।

যেমন:

```js run
let today = new Date();

today.setHours(0);
alert(today); // বর্তমান তারিখ দেখাবে এবং ঘন্টা পরিবর্তন হবে, কিন্তু মিনিট বা সেকেন্ডের কোন পরিবর্তন হবে না

today.setHours(0, 0, 0, 0);
alert(today); // বর্তমান তারিখ দেখাবে এবং সময় দেখাবে 00:00:00।
```

## অটোকারেকশন

`Date` অবজেক্ট এর দারুন একটি ফিচার হল এটি আমাদের ভুল সময়কে *অটোকারেকশন* করে নিতে পারে। যদি আমরা অনিচ্ছাকৃতভাবে কোন ভুল ইনপুট দিয়ে ফেলি, তাহলে এটি স্বয়ংক্রিয়ভাবে সময় ঠিক করে নেয়।

যেমন:

```js run
let date = new Date(2013, 0, *!*32*/!*); // 32 জানুয়ারী 2013 ?!?
alert(date); // ...অর্থাৎ এটি হবে ১লা ফেব্রুয়ারী 2013!
```

এই অটোকারেকশন ফিচারটি মেথডের ক্ষেত্রেও কাজ করবে।

মনে করুন আমরা "28 ফেব্রুয়ারী 2016" এর সাথে ২দিন যোগ করব, এক্ষেত্রে এটি অধিবর্ষের(লিপ ইয়ার) জন্য "২রা মার্চ" অথবা "১লা মার্চ" হতে পারে। আমাদের এ ব্যাপারে চিন্তা করতে হবে না, কেননা `Date` অবজেক্ট স্বয়ংক্রিয়ভাবে এটি ব্যবস্থা নিতে পারে:

```js run
let date = new Date(2016, 1, 28);
*!*
date.setDate(date.getDate() + 2);
*/!*

alert( date ); // 1 Mar 2016
```

এই ফিচারটি আমরা একটি নির্দিষ্ট সময়ের পরের সময় জানতেও কাজে আসে, মনে করুন আমরা "বর্তমান সময়ের 70 সেকেন্ড পরের সময়টি" জানতে চাই:

```js run
let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date );
```

আমরা শুন্য অথবা ঋণাত্নক মানও সেট করতে পারি, যেমন:

```js run
let date = new Date(2016, 0, 2); // 2রা জানুয়ারি 2016

date.setDate(1); // এখন ১ তারিখ সেট করলাম
alert( date );

date.setDate(0); // যেহেতু সর্বনিম্ন তারিখ হতে পারে 1, সুতরাং এটি এর আগের দিন দেখাবে
alert( date ); // 31 Dec 2015
```

## তারিখের পার্থক্য এবং তারিখ এর টাইমস্ট্যাম্প

যখন `Date` অবজেক্টকে নাম্বারে রূপান্তর করা হয় তখন এটি `date.getTime()` এর মত টাইমস্ট্যাম্প রিটার্ন করে:

```js run
let date = new Date();
alert(+date); // date.getTime() এর মত মিলিসেকেন্ড রিটার্ন করে
```

তবে গুরুত্বপূর্ন ব্যাপার হল আমরা এর সাহায্যে দুটি সময়ের মিলিসেকেন্ডের পার্থক্যও বের করতে পারি।

আমরা এটি সময় এর পার্থক্য নির্ণয়ের জন্য ব্যবহার করি:

```js run
let start = new Date(); // শুরু

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // শেষ

alert( `The loop took ${end - start} ms` );
```

## Date.now()

তবে শুধুমাত্র সময় পরিমাপের জন্য `Date` অবজেক্ট এর প্রয়োজন নেই।

একটি বিশেষ মেথড আছে `Date.now()` যা বর্তমান টাইমস্ট্যাম্প রিটার্ন করে।

এটি অনেকটা `new Date().getTime()` এর মতই, কিন্তু এটি প্রথমে `Date` অবজেক্ট তৈরি করে না। সুতরাং এটি `new Date().getTime()` এর তুলনায় দ্রুত কাজ করে এবং গার্বেজ কালেকশনের জন্য অতিরিক্ত সময় ব্যয় করে না।

বেশিরভাগ ক্ষেত্রে এটি ব্যবহার করা হয় পারফরম্যান্সের জন্য, যেমন গেম বা অন্যান্য বিশেষ অ্যাপ্লিকেশন।

এক্ষেত্রে এটি ব্যবহার করা উচিত:

```js run
*!*
let start = Date.now();
*/!*

// do the job
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

*!*
let end = Date.now(); // done
*/!*

alert( `The loop took ${end - start} ms` );
```

## বেঞ্চমার্কিং

যদি আমরা অধিক CPU ব্যবহার করে, এমন ফাংশনের বেঞ্চমার্ক করতে চাই, আমাদের সতর্ক থাকা উচিত।

যেমন, আমরা আমাদের দুটি ফাংশন আছে যারা দুটি সময়ের পার্থক্য ক্যালকুলেশন করে, এক্ষেত্রে কোনটি দ্রুত কাজ করবে?

এই ধরণের পারফরম্যান্স পরিমাপকে বলা হয় "benchmarks"।

```js
// নিচের দুটি ফাংশনের একটি `Date` অবজেক্ট ব্যবহার করে ক্যালকুলেশন করছে, অন্যটি `getTime()` ব্যবহার করে, কোনটি দ্রুত কাজ করবে?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// অথবা
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
```

এখানে দুটি ফাংশনের কাজ একই, তবে একটি ক্যাল্কুলেট করছে `date.getTime()` এর সাহায্যে অন্যটি `Date` অবজেক্ট কে নাম্বারে(টাইপ কাস্টিং) কনভার্ট করে। এরা উভয়ই সঠিক রেজাল্ট দেখাবে।

কোনটি দ্রুত কাজ করবে?

যেহুতু ফাংশন দুটি একেবারে সাধারণ সুতরাং আমরা দুটি ফাংশনকে অনেকবার কল করে তাদের মাঝের সময় নির্ণয় করতে পারি, এক্ষেত্রে চলুন এদের কমপক্ষে ১০০০০০ বার কল করি।

সম্পূর্ন ক্যালকুলেশনটি হবে এমন:

```js run
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );
alert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );
```

এখানে কি দেখলেন!? `getTime()` অনেক দ্রুত কাজ করছে! কেননা এটির ক্ষেত্রে আলাদা করে কোন টাইপ কনভার্শন করা লাগছে না, যার জন্য ইঞ্জিন সহজে অপ্টিমাইজ করতে পারছে।

ইতোমধ্যে, আমরা ব্যাপারটি বুঝতে পারলাম। তবে এটিকে এখনো ভালো বেঞ্চমার্কিং বলা যাবে না।

মনে করুন `bench(diffSubtract)` কোডটি রান করার সময় আমাদের CPU প্যারালাল ভাবে অন্য কোন কাজ করে, এবং আলাদা কিছু রিসোর্স ব্যবহার করে। এবং ঐ সময়ের মাঝে `bench(diffGetTime)` এর কাজ শেষ হচ্ছে।

যা বর্তমান আধুনিক OS গুলোর ক্ষেত্রে হরহামেশাই হয়।

যার ফলে, আমাদের বেঞ্চমার্কিং এর ফলাফল ভুল দেখাতে পারে।

**এজন্য নির্ভুলভাবে বেঞ্চমার্কিং এর জন্য, আমাদের বেঞ্চমার্কিং কোডটিকে কয়েকবার চালানো উচিত**

এইভাবে:

```js run
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

*!*
// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
*/!*

alert( 'Total time for diffSubtract: ' + time1 );
alert( 'Total time for diffGetTime: ' + time2 );
```

আধুনিক জাভাস্ক্রিপ্ট ইঞ্জিন গুলোতে "hot code" (যেখানে কম্পাইলারের বেশি সময় লাগতে পারে) এর জন্য এই ধরণের কোডের ক্ষেত্রে আমরা একটি "heat-up" সংযুক্ত করতে পারি:

```js
// added for "heating up" prior to the main loop
bench(diffSubtract);
bench(diffGetTime);

// now benchmark
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
```

```warn header="মাইক্রোবেঞ্চমার্কিং এর সময় আরো সতর্ক থাকা উচিত"
মডার্ন জাভাস্ক্রিপ্ট ইঞ্জিন সমূহ যথেষ্ট অপ্টিমাইজভাবে কাজ করে। এক্ষেত্রে সাধারণ ব্যবহার যোগ্য সমস্যা গুলোর সাথে আর্টিফিশিয়াল টেস্ট এর রেজাল্টে অসামাঞ্জস্য দেখা দিতে পারে, যেমন যদি আমরা একেবারে মাইক্রোবেঞ্চমার্কিং অর্থাৎ একটি অপারেটর কিভাবে কাজ করছে, অথবা বিল্ট-ইন ফাংশন কেমন সময় নিবে। আপনি যদি এমন পারফরম্যন্স সম্পর্কে জানতে আরো বেশি আগ্রহী হন মাইক্রোবেঞ্চমার্কিং না করে জাভাস্ক্রিপ্ট ইঞ্জিন কীভাবে কাজ করে তা বুঝলে হবে।

V8 ইঞ্জিন সম্পর্কে জানতে এটি একটি দারুন রিসোর্স <http://mrale.ph>।
```

## স্ট্রিং হতে সময় বের করার মেথড Date.parse()

[Date.parse(str)](mdn:js/Date/parse) মেথডটি স্ট্রিং হতে সময় রূপান্তর করতে পারে।

স্ট্রিংয়ের ফরম্যট হবে: `YYYY-MM-DDTHH:mm:ss.sssZ`, যেখানে:

<<<<<<< HEAD
- `YYYY-MM-DD` -- তারিখ: year-month-day.
- ক্যারাক্টার `"T"` ব্যবহার হয় ডেলিমিটার হিসেবে।
- `HH:mm:ss.sss` -- সময়: hours, minutes, seconds এবং milliseconds.
- `'Z'` অপশনাল যা টাইমজোনকে নির্দেশ করে `+-hh:mm`, যেমন বাংলাদেশের (UTC+6) জন্য '2020-01-26T13:51:50.417+06:00'। শুধুমাত্র `Z` বুঝায় UTC+0
=======
- `YYYY-MM-DD` -- is the date: year-month-day.
- The character `"T"` is used as the delimiter.
- `HH:mm:ss.sss` -- is the time: hours, minutes, seconds and milliseconds.
- The optional `'Z'` part denotes the time zone in the format `+-hh:mm`. A single letter `Z` would mean UTC+0.
>>>>>>> 2cca9a9d09fdd45819832294225aa3721fa5a2d4

এছাড়াও আমরা সংক্ষিপ্তভাবে এদের কল করতে পারি, যেমন `YYYY-MM-DD` বা `YYYY-MM` এমনকি `YYYY`।

`Date.parse(str)` স্ট্রিং হতে টাইমস্ট্যাম্পকে মিলিসেকেন্ড হিসেবে রিটার্ন করে (১৯৭০ সালের ১লা জানুয়ারি(UTC+0) হতে অতিক্রান্ত মিলিসেকেন্ড)। ইনভ্যালিড স্ট্রিং ফরম্যাটের জন্য রিটার্ন করবে `NaN`।

যেমন:

```js run
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417  (timestamp)
```

আমরা টাইমস্ট্যাম্প হতে `new Date` অবজেক্ট তৈরি করতে পারি:

```js run
let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
```

## সারাংশ

- জাভাস্ক্রিপ্টে সময় এবং তারিখ উভয়ই কাজ করে [Date](mdn:js/Date) অবজেক্ট দ্বারা। আমরা শুধুমাত্র সময় বা তারিখকে আলাদা করে কল করতে পারব না `Date` অবজেক্ট উভয়ই সংরক্ষণ করে।
- মাসের গণনা শুরু হয় শূন্য হতে (০ দ্বারা বুঝায় জানুয়ারি).
- সপ্তাহের বারও শুরু হয় শূন্য হতে `getDay()`(০ দ্বারা বুঝায় রবিবার).
- `Date` অবজেক্ট এর সাথে সময় বা দিন যোগ বিয়োগের সময় তারিখ স্বয়ংক্রিয়ভাবে ঠিক করে নেই।
- দুটি সময়ের মধ্যে মিলিসেকেন্ডের পার্থক্যও বের করা সম্ভব। কারণ `Date` টাইপ কাস্টিং হয়ে টাইমস্ট্যাম্পে রূপান্তর হতে পারে।
- বর্তমান টাইমস্ট্যাম্প পেতে `Date.now()` `new Date()` হতে অধিক দ্রুত কাজ করে।

আমাদের মনে রাখা উচিত, জাভাস্ক্রিপ্ট টাইমস্ট্যাম্পকে মিলিসেকেন্ডে রিটার্ন করে, সেকেন্ডে নয়।

অনেক সময় আমাদের আরো নির্ভুলভাবে পরিমাপ করা লাগতে পারে। এজন্য জাভাস্ক্রিপ্টের মাইক্রোসেকেন্ডে (১ সেকেন্ডের ১০লাখ ভাগ) ক্যালকুলেশনের কোন বিল্ট-ইন মেথড নাই। তবে বেশিরভাগ এইভাইরনমেন্টের কিছু মেথড আছে। যেমন ব্রাউজারের ক্ষেত্রে [performance.now()](mdn:api/Performance/now) যা পেজ লোডিংয়ের পর থেকে মাইক্রোসেকেন্ডের সময় রিটার্ন করতে পারে।

```js run
alert(`Loading started ${performance.now()}ms ago`);
<<<<<<< HEAD
// এটি দেখাবে এমন কিছু: "Loading started 34731.26000000001ms ago"
// .26 হল মাইক্রোসেকেন্ড (260 microseconds)
// দশমিকের পর ৩ ঘর পর্যন্ত সঠিক মান দেখাতে পারে
=======
// Something like: "Loading started 34731.26000000001ms ago"
// .26 is microseconds (260 microseconds)
// more than 3 digits after the decimal point are precision errors, only the first 3 are correct
>>>>>>> 2cca9a9d09fdd45819832294225aa3721fa5a2d4
```

Node.js এর আছে `microtime` মডুইল। সাধারণত প্রতিটি এনভায়রনমেন্টের নিজস্ব মেথড আছে যা `Date` এর তুলনায় আরো নির্দিষ্ট সময় নির্ভুলভাবে প্রদান করতে পারে।
