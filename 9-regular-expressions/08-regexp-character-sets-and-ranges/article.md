# সেট এবং রেঞ্জ [...]

তৃতীয় বন্ধনীর `[…]` এর মধ্যে বিভিন্ন ক্যারাক্টার অথবা বিভিন্ন ক্যারাক্টার ক্লাসের দ্বারা বুঝায় "প্রদত্ত ক্যারাক্টারসমূহের যেকোন একটি ক্যারাক্টার থাকতে পারে"।

## সেট

উদাহরণস্বরূপ, `pattern:[eao]` এর মানে `'a'`, `'e'`, বা `'o'` এ ৩টি ক্যারাক্টারের যেকোন একটি।

একে বলা হয় *সেট*। রেগুলার এক্সপ্রেশন প্যাটার্নে রেগুলার ক্যারাক্টারের সাথে সেটও ব্যবহার করা যায়:

```js run
// প্রথমে [t বা m] খুঁজবে, এবং তারপর "op"
alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"
```

দয়া করে মনে রাখা উচিত সেটে অনেক ক্যারাক্টার থাকলেও, এরা যেকোন একটি ক্যারাক্টারের সাথে ম্যাচ করে।

সুতরাং নিচের উদাহরণটিতে কোন ম্যাচ হবেনা:

```js run
// প্রথমে "V", তারপর [o অথবা i], তারপর "la"
alert( "Voila".match(/V[oi]la/) ); // null, কোন ম্যাচ হবেনা
```

প্যাটার্নটি এভাবে সার্চ করে:

- `pattern:V`,
- তারপর যেকোন *একটি* অক্ষর `pattern:[oi]`,
- তারপর `pattern:la`।

সুতরাং এটি `match:Vola` অথবা `match:Vila` এর সাথে ম্যাচ হতে পারে।

## রেঞ্জ

তৃতীয় বন্ধনীতে *ক্যারাক্টারের রেঞ্জ*-ও থাকতে পারে।

উদাহরণস্বরূপ, `pattern:[a-z]` হল `a` হতে `z` পর্যন্ত ক্যারাক্টারসমূহের রেঞ্জ, এবং `pattern:[0-5]` হল `0` হতে `5` ডিজিটসমূহের রেঞ্জ।

নিচের উদাহরণটিতে আমরা হেক্সাডেসিমেল সংখ্যার জন্য `"x"` এর পর দুটি ডিজিট অথবা `A` to `F` পর্যন্ত অক্ষরগুলো খুঁজি:

```js run
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF
```

এখানে `pattern:[0-9A-F]` এর দুটি রেঞ্জ রয়েছে: এটি সার্চ করে কোন ক্যারাক্টার `0` হতে `9` অথবা `A` হতে `F` এর মধ্যে আছে কিনা তা চেক করে।

যদি আমরা ছোট হাতের অক্ষর দিয়েও খুঁজতে চাই, আমরা এই `a-f` রেঞ্জটাও যুক্ত করতে পারি: `pattern:[0-9A-Fa-f]`। অথবা এই ফ্ল্যাগটাও `pattern:i` যুক্ত করতে পারি।

আমরা `[…]` এর মধ্যে ক্যারাক্টার ক্লাসও ব্যবহার করতে পারি।

উদাহরণস্বরূপ, যদি আমরা কোন ওয়ার্ডলি ক্যারাক্টার `pattern:\w` অথবা হাইফেন `pattern:-` খুঁজতে চাই সেটটি হবে এমন `pattern:[\w-]`।

অনেকগুলো ক্লাসকে একসাথে করা যায়, যেমন `pattern:[\s\d]` দ্বারা বুঝায় "একটি স্পেস ক্যারাক্টার অথবা একটি ডিজিট"।

```smart header="ক্যারাক্টার ক্লাসগুলো নির্দিষ্ট ক্যারাক্টার সেটের শর্টহ্যান্ড"
উদাহরণস্বরূপ:

<<<<<<< HEAD
- **\d** -- এটি `pattern:[0-9]` এর মত,
- **\w** -- এটি `pattern:[a-zA-Z0-9_]` এর মত,
- **\s** -- এটি `pattern:[\t\n\v\f\r ]` এর মত, এছাড়াও আরো কিছু ইউনিকোড স্পেস ক্যারাক্টার।
=======
- **\d** -- is the same as `pattern:[0-9]`,
- **\w** -- is the same as `pattern:[a-zA-Z0-9_]`,
- **\s** -- is the same as `pattern:[\t\n\v\f\r ]`, plus few other rare Unicode space characters.
>>>>>>> d694e895efe89922a109702085b6ca1efeffea10
```

### উদাহরণ: মাল্টি-ল্যাংগুয়েজ \w

যেহেতু `pattern:[a-zA-Z0-9_]` এর শর্টহ্যান্ড ক্যারাক্টার ক্লাস হল `pattern:\w`, তাই এটি দ্বারা চাইনিজ, সিরিলিক ইত্যাদি ভাষার অক্ষরগুলো পাওয়া যায় না।

<<<<<<< HEAD
আমরা আরো সহজে প্যাটার্ন লিখতে পারি, যা দ্বারা যেকোন ভাষার ওয়ার্ডলি ক্যারাক্টার খুঁজা যায়। ইউনিকোড প্রপার্টি দ্বারা সহজে করা যায়: `pattern:[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]`।

চলুন এর মর্মার্থ বুঝি. এটি `pattern:\w` এর মত আমরা নিজেদের একটি সেট তৈরি করেছি যাতে নিম্নলিখিত ইউনিকোড বৈশিষ্ট্যযুক্ত অক্ষরসমূহ অন্তর্ভুক্ত:
=======
We can write a more universal pattern, that looks for wordly characters in any language. That's easy with Unicode properties: `pattern:[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]`.

Let's decipher it. Similar to `pattern:\w`, we're making a set of our own that includes characters with following Unicode properties:
>>>>>>> d694e895efe89922a109702085b6ca1efeffea10

- `Alphabetic` (`Alpha`) - বর্ণের জন্য,
- `Mark` (`M`) - অ্যাকসেন্টের জন্য,
- `Decimal_Number` (`Nd`) - ডিজিটের জন্য,
- `Connector_Punctuation` (`Pc`) - আন্ডারস্কোর `'_'` এবং এ ধরণের ক্যারাক্টারের জন্য,
- `Join_Control` (`Join_C`) - দুটি বিশেষ কোড `200c` এবং `200d`, লিগচারে ব্যবহৃত হয় যেমন আরবীতে।

উদাহরণস্বরূপ:

```js run
let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

let str = `Hi 你好 12`;

// সব অক্ষর এবং ডিজিট পাব:
alert( str.match(regexp) ); // H,i,你,好,1,2
```

<<<<<<< HEAD
অবশ্যই, আমরা প্যাটার্নটি ইডিট করতে পারি: নতুন প্রপার্টি সংযুক্ত বা বাদ দিতে পারি। ইউনিকোড প্রপার্টি সম্পর্কে বিস্তারিত এখানে জানতে পারবেন <info:regexp-unicode>।

```warn header="ইউনিকোড প্রপার্টি ফায়ারফক্স এবং এজে সমর্থিত নয়"
ইউনিকোড প্রপার্টিসমূহ `pattern:p{…}` ফায়ারফক্স এবং এজে সমর্থিত নয়. যদি আমাদের দরকার হয়, তাহলে এই লাইব্রেরীটি ব্যবহার করতে হবে [XRegExp](http://xregexp.com/)।
=======
Of course, we can edit this pattern: add Unicode properties or remove them. Unicode properties are covered in more details in the article <info:regexp-unicode>.

```warn header="Unicode properties aren't supported in IE"
Unicode properties `pattern:p{…}` are not implemented in IE. If we really need them, we can use library [XRegExp](https://xregexp.com/).
>>>>>>> d694e895efe89922a109702085b6ca1efeffea10

অথবা শুধু নির্দিষ্ট ভাষার রেঞ্জ ব্যবহার করতে পারি, যেমন:  `pattern:[а-я]` সিরিলিক বর্ণের জন্য।
```

## এক্সক্লুডিং রেঞ্জ

নরমাল রেঞ্জের পাশাপাশি "এক্সক্লুডিং" রেঞ্জ আছে যার প্যাটার্নটি এমন `pattern:[^…]`।

এটি রেঞ্জের শুরুতে ক্যারেট ক্যারাক্টার `^` দ্বারা লিখা হয় এবং *শুধুমাত্র রেঞ্জ সেটটি ব্যতীত* বাকী সকল ধরণের ক্যারাক্টারের সাথে ম্যাচ হয়।

উদাহরণস্বরূপ:

- `pattern:[^aeyo]` -- `'a'`, `'e'`, `'y'` বা `'o'` ব্যতীত যেকোন ক্যারাক্টার।
- `pattern:[^0-9]` -- ডিজিট ব্যতীত যেকোন ক্যারাক্টার,  `pattern:\D` এর মত।
- `pattern:[^\s]` -- যেকোন নন-স্পেস ক্যারাক্টার, `\S` এর মত।

নিচের উদাহরণটিতে অক্ষর, ডিজিট, স্পেস ব্যতীত অন্যান্য ক্যারাক্টার পাব:

```js run
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ এবং .
```

## […] এস্কেপিং

সাধারণত যখন আমরা স্পেশাল ক্যারাক্টার খুঁজি আমাদের ক্যারাক্টারটিকে এস্কেপ করে নিতে হয় যেমন `pattern:\.`, ব্যাকস্ল্যাশের জন্য `pattern:\\` ইত্যাদি।

তবে তৃতীয় বন্ধনীর এর মধ্যে বেশিরভাগ স্পেশাল ক্যারাক্টার এস্কেপিং ছাড়া ব্যবহার করা যায়:

- সিম্বলস `pattern:. + ( )` এস্কেপিংয়ের প্রয়োজন নেই।
- হাইফেন `pattern:-` শুরুতে অথবা শেষে এস্কেপিংয়ের প্রয়োজন নেই (যখন এটি দ্বারা রেঞ্জ বুঝায় না)।
- ক্যারেট `pattern:^` শুধুমাত্র শুরুতে এস্কেপ করে নিতে হয় (যেখানে এটি দ্বারা বুঝানো হয় সেটটি ব্যতীত)।
- ক্লোজিং ব্রাকেট `pattern:]` কে সর্বদা এস্কেপ করতে হয় (যদি আমাদের এটি ম্যাচ করতে হয়)।

অন্যার্থে বলা যায়, তৃতীয় বন্ধনীতে যেসব স্পেশাল ক্যারাক্টার ব্যবহৃত হয় সেসব ব্যতীত সকল স্পেশাল ক্যারাক্টার এস্কেপিং ছাড়া ব্যবহার করতে পারব।

তৃতীয় বন্ধনীতে ডট `.` দ্বারা শুধুমাত্র ডট বুঝায়। প্যাটার্নটি `pattern:[.,]` যেকোন একটি ক্যারাক্টার খুঁজবে: ডট অথবা কমা।

নিম্নের উদাহরণে `pattern:[-().^+]` প্যাটার্নটি `-().^+` এসব ক্যারাক্টার খুঁজবে:

```js run
// এস্কেপ করার প্রয়োজন নেই
let regexp = /[-().^+]/g;

alert( "1 + 2 - 3".match(regexp) ); // Matches +, -
```

...কিন্তু আপনি যদি "কোন ক্ষেত্রে" এদের এস্কেপ করেন, তাহলেও এটি আগের উদাহরণের মত কাজ করবে:

```js run
// সব ক্যারাক্টারকে এস্কিপিং করা হয়েছে
let regexp = /[\-\(\)\.\^\+]/g;

alert( "1 + 2 - 3".match(regexp) ); // এটিও কাজ করে: +, -
```

## রেঞ্জ এবং ফ্ল্যাগ "u"

যদি সেটে কোন "সারোগেট জোড়" <info:string> থাকে, তাহলে সঠিকভাবে কাজ করার জন্য `pattern:u` ফ্ল্যাগটি ব্যবহার করতে হবে।

উদাহরণস্বরূপ, চলুন এই স্ট্রিংয়ে `subject:𝒳` আমরা এই প্যাটার্নটি খুঁজি `pattern:[𝒳𝒴]`:

```js run
alert( '𝒳'.match(/[𝒳𝒴]/) ); // এমন [?] অদ্ভুত একটি ক্যারাক্টার দেখাবে
// (সার্চিংটি সঠিকভাবে কাজ করবে না, হাফ-ক্যারেক্টার রিটার্ন করবে)
```

রেজাল্টটি সঠিকভাবে পাব না, কেননা ডিফল্টভাবে রেগুলার এক্সপ্রেশন "সারোগেট জোড়" সম্পর্কে জানেনা।

রেগুলার এক্সপ্রেশন ইঞ্জিন `[𝒳𝒴]` -- একে দুটি ক্যারাক্টারের বদলে চারটি ক্যারাক্টার ভাবে:
1. `𝒳` `(1)` এর বামের অর্ধেক,
2. `𝒳` `(2)` এর ডানের অর্ধেক,
3. `𝒴` `(3)` এর বামের অর্ধেক,
4. `𝒴` `(4)` এর ডানের অর্ধেক।

নিম্নে আমরা তাদের কোডগুলো দেখতে পাই:

```js run
for(let i=0; i<'𝒳𝒴'.length; i++) {
  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500
};
```

সুতরাং, উপরের উদাহরণে আমরা `𝒳` এর বামের অর্ধেক পাই।

যদি আমরা ফ্ল্যাগ `pattern:u` ব্যবহার করি, তাহলে এটি সঠিকভাবে কাজ করবে:

```js run
alert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳
```

রেঞ্জের জন্যও এই ঘটনাটি ঘটে, যেমন `[𝒳-𝒴]`।

যদি আমরা ফ্ল্যাগ `pattern:u` ব্যবহার না করি, তাহলে একটি ইরোর পাব:

```js run
'𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression
```

ফ্ল্যাগ `pattern: u` ছাড়া "সারোগেট জোড়া" এর কারণে দুটি অক্ষর হিসেবে বিবেচনা করে, সুতরাং `[𝒳-𝒴]` এটি এভাবে `[<55349><56499>-<55349><56500>]` বিবেচিত হয় (প্রতিটি সারোগেট জোড় তার কোড দ্বারা প্রতিস্থাপিত হয়)। এখন রেঞ্জটি এভাবে বিবেচিত হয় `56499-55349` যা ইনভ্যালিড: কেননা রেঞ্জের শুরুর ক্যারাক্টারটি `56499` শেষের ক্যারাক্টার হতে বড় `55349`। এই কারণেই ইরোরটি সংঘটিত হয়।

ফ্ল্যাগ `pattern:u` এর সাথে প্যাটার্নটি সঠিকভাবে কাজ করে:

```js run
// 𝒳 to 𝒵 পর্যন্ত ক্যারাক্টার সমূহকে খুঁজে
alert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴
```
