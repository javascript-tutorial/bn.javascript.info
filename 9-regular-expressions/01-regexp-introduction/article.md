# প্যাটার্ন এবং ফ্ল্যাগ

টেক্সটে কোনকিছু খোঁজা অথবা রিপ্লেস করার একটি পাওয়ারফুল মাধ্যম হল রেগুলার এক্সপ্রেশন।

জাভাস্ক্রিপ্টে এটি [RegExp](mdn:js/RegExp) অবজেক্টের অধীনে আছে এবং স্ট্রিং এর মেথডগুলোর মধ্যে এদের ব্যবহার করতে পারি।

## রেগুলার এক্সপ্রেশনস

রেগুলার এক্সপ্রেশন (যা "regexp" অথবা "reg" নামেও পরিচিত) হল *প্যাটার্ন* এবং অপশনাল *ফ্ল্যাগ* এর মাধ্যমে গঠিত একটি সমন্বিতরূপ।

দুইভাবে আমরা রেগুলার এক্সপ্রেশন অবজেক্ট তৈরি করতে পারি।

"লং" সিনট্যাক্সঃ

```js
regexp = new RegExp("প্যাটার্ন", "ফ্ল্যাগ");
```

এবং "শর্ট" সিনট্যাক্স যা `"/"` দ্বারা ডিক্লেয়ার করা হয়ঃ

```js
regexp = /pattern/; // ফ্ল্যাগ ছাড়া
regexp = /pattern/gmi; // ফ্ল্যাগ সহ g,m and i (এগুলো সম্পর্কে সামনেই জানতে পারব)
```

স্ল্যাস `pattern:/.../` ব্যবহারের মাধ্যমে জাভাস্ক্রিপ্ট ইঞ্জিন বুঝতে পারে এটি একটি রেগুলার এক্সপ্রেশন। যেভাবে `""` অথবা `''` দ্বারা স্ট্রিং কে চিনতে পারে।

উভয়ক্ষেত্রে `regexp` বিল্টইন `RegExp` ক্লাস এর ইনস্ট্যান্স হিসেবে তৈরি হয়।

এই দুই সিনট্যাক্সের মূল পার্থক্য হল `/.../` এখানে ডাইনামিক্যালি কোন ভেরিয়েবল (যেমনঃ টেমপ্লেট লিটারেলস স্ট্রিং `${...}`) ব্যবহার করতে পারবেন না। এটি পুরোপুরি স্ট্যাটিক।

<<<<<<< HEAD
বেশিরভাগ ক্ষেত্রে কোড লিখার সময় যখন আমরা রেগুলার এক্সপ্রেশনটি জানি তখন স্ল্যাস ব্যবহার করি। আর `new RegExp` ব্যবহার করি যখন আমাদের প্যাটার্ন জেনারেট করতে হয় ডাইনামিক্যালি। উদাহরণস্বরুপঃ
=======
Slashes are used when we know the regular expression at the code writing time -- and that's the most common situation. While `new RegExp` is more often used when we need to create a regexp "on the fly" from a dynamically generated string. For instance:
>>>>>>> 4d01fc20d4d82358e61518a31efe80dec9bb2602

```js
let tag = prompt("আপনি কোন ট্যাগটি খুঁজতে চাচ্ছেন?", "h2");

let regexp = new RegExp(`<${tag}>`); // এটি /<h2>/ এর মত যদি prompt এ ইনপুট h2 দেয় 
```

## ফ্ল্যাগ

রেগুলার এক্সপ্রেশনে কিছু ফ্ল্যাগ আছে যা সার্চিং এর সময় ব্যবহৃত হয়।

জাভাস্ক্রিপ্টে ৬ ধরনের ফ্ল্যাগ আছেঃ

`pattern:i`
: এই ফ্ল্যাগটি কেস ইনসেনসিটিভ বুঝায়ঃ `A` এবং `a` এর মধ্যে কোন পার্থক্য নেই (নিচের উদাহরণ দেখুন)।

`pattern:g`
: এই ফ্ল্যাগটি টেক্সটে সব মিল খুঁজে, এটি ছাড়া -- শুধু প্রথম মিলটি রিটার্ন করে।

`pattern:m`
: মাল্টিলাইন মোড (বিস্তারিত এই অধ্যায়ে <info:regexp-multiline-mode>)।

`pattern:s`
: "dotall" মোড, নিউলাইন ক্যারেক্টার `\n` কে ডট `pattern:.` দিয়ে খোঁজা যায় (বিস্তারিত এই অধ্যায়ে <info:regexp-character-classes>).

`pattern:u`
<<<<<<< HEAD
: ফুল ইউনিকোর্ড সাপোর্ট এনাবল করে। ফ্ল্যাগটি সঠিকভাবে সারোগেটজোড় কে প্রসেসিংয়ের সাপোর্ট দেয়। আরো জানতে পারবেন এই অধ্যায়ে <info:regexp-unicode>।
=======
: Enables full Unicode support. The flag enables correct processing of surrogate pairs. More about that in the chapter <info:regexp-unicode>.
>>>>>>> 4d01fc20d4d82358e61518a31efe80dec9bb2602

`pattern:y`
: "Sticky" মোডঃ সার্চিং এর সময় টেক্সটে এক্স্যাক্ট পজিশনটি জানা যায় (বিস্তারিত এই অধ্যায়ে <info:regexp-sticky>)

```smart header="কালারস"
এখানে কালার স্কিমটা হলঃ

- regexp -- `pattern:red`
- string (যেখানে আমরা সার্চ করি) -- `subject:blue`
- result -- `match:green`
```

## সার্চিংঃ str.match

আমরা পূর্বেই জেনেছি, রেগুলার এক্সপ্রেশনগুলো স্ট্রিংয়ের মেথডগুলোর সাথে ইন্টিগ্রেটেড।

`str.match(regexp)` মেথডটির সাহায্যে `str` এর মধ্যে `regexp` এর সকল মিল খুঁজা যায়।

এটির ৩ ধরণের মোড আছেঃ

1. যদি রেগুলার এক্সপ্রেশনে `pattern:g` এই ফ্ল্যাগটি ব্যবহৃত হয়, এটি সব মিলপ্রাপ্ত প্যাটার্নগুলোকে অ্যারেতে রিটার্ন করেঃ
    ```js run
    let str = "We will, we will rock you";

    alert( str.match(/we/gi) ); // We,we (অ্যারে আকারে এই ২টি সাবস্ট্রিং রিটার্ন করবে)
    ```
    লক্ষ্য করুন এখানে `match:We` এবং `match:we` দুটিই দেখাবে, যেহেতু আমরা কেস-ইনসেনসিটিভ ফ্ল্যাগটি ব্যবহার করেছি।

2. যদি আমরা কোন ফ্ল্যাগ ব্যবহার না করি তাহলে এটি প্রথম মিলটিকে অ্যারে আকারে রিটার্ন করবে, সম্পূর্ন মিলটিকে আমরা ইনডেক্স `0` তে পাই এবং প্রপার্টিগুলোর অতিরিক্ত কিছু বর্ননাঃ
    ```js run
    let str = "We will, we will rock you";

    let result = str.match(/we/i); // ফ্ল্যাগ g ছাড়া

    alert( result[0] );     // We (১ম মিল)
    alert( result.length ); // 1

    // Details:
    alert( result.index );  // 0 (প্রাপ্ত মিলের পজিশন)
    alert( result.input );  // We will, we will rock you (source string)
    ```
    `0` এর পাশাপাশি অ্যারের অন্যান্য ইনডেক্সও থাকতে পারে যদি এক্সপ্রেশনটিতে প্রথম বন্ধনী থাকে। আমরা এই অধ্যায়ে এসম্পর্কে বিস্তারিত জানতে পারব  <info:regexp-groups>।

3. এবং, সর্বশেষে যদি কোন মিল খুঁজে পাওয়া না যায় `null` রিটার্ন করবে (এটি `pattern:g` ফ্ল্যাগের উপর নির্ভর করে না)।

    একটি গুরুত্বপূর্ন ব্যাপার খেয়াল রাখা উচিত। কোন মিল খুঁজে পাওয়া না গেলে এম্পটি স্ট্রিং এর বদলে `null` রিটার্ন করে। এজন্য এম্পটি চেকিংয়ের জন্য ভুলভাবে চেকিংয়ের জন্য এরর পেতে পারেন, যেমনঃ

    ```js run
    let matches = "JavaScript".match(/HTML/); // = null

    if (!matches.length) { // Error: Cannot read property 'length' of null
      alert("Error in the line above");
    }
    ```

    নিম্নোক্ত উপায়ে রেজাল্ট আমরা সর্বদা অ্যারে হিসেবে চেক করতে পারিঃ

    ```js run
    let matches = "JavaScript".match(/HTML/)*!* || []*/!*;

    if (!matches.length) {
      alert("No matches"); // এখন এটি কাজ করবে
    }
    ```

## রিপ্লেসিংঃ str.replace

`str.replace(regexp, replacement)` মেথডটি `regexp` দ্বারা প্রাপ্ত সব মিলকে `replacement` করে `pattern:g` ফ্ল্যাগের জন্য, অন্যথায় শুধু প্রথম মিলটিকে রিপ্লেস করে। 

উদাহরণস্বরূপঃ

```js run
// g ফ্ল্যাগ ছাড়া
alert( "We will, we will".replace(/we/i, "I") ); // I will, we will

// g ফ্ল্যাগ সহ
alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will
```

দ্বিতীয় আর্গুমেন্টে `replacement` স্ট্রিংটি পাস করা হয়। মিল খুঁজে পাওয়া অংশগুলো `replacement` এর সাথে ব্যবহার করতে আমরা কিছু স্পেশাল ক্যারেক্টার সংযুক্ত করতে পারি। 

| সিম্বলস | রিপ্লসমেন্ট স্ট্রিংয়ে সংগঠিত অ্যাকশন |
|--------|--------|
|`$&`|পুরো মিলটিকে সংযুক্ত করে|
|<code>$&#096;</code>|মিলের আগ পর্যন্ত স্ট্রিংকেও সংযুক্ত করে|
|`$'`|মিলের পরের স্ট্রিংকেও সংযুক্ত করে|
|`$n`|যদি `n` ১-২ ডিজিটের নাম্বার হয়, আমরা বন্ধনী দ্বারা পাওয়া মানগুলোকে `$n` সংযুক্ত করতে পারি, বিস্তারিত এই অধ্যায়ে <info:regexp-groups>|
|`$<name>`|আমরা বন্ধনী দ্বারা পাওয়া মানগুলোকে `name` সংযুক্ত করতে পারি,বিস্তারিত এই অধ্যায়ে <info:regexp-groups>|
|`$$`|`$` ক্যারাক্টারটি সংযুক্ত করতে|

`pattern:$&` এর একটি উদাহরণঃ

```js run
alert( "I love HTML".replace(/HTML/, "$& and JavaScript") ); // I love HTML and JavaScript
```

## টেস্টিংঃ regexp.test

`regexp.test(str)` মেথডটি অন্তত একটি মিল খুঁজে পেলে `true` রিটার্ন করে, অন্যথায় `false` রিটার্ন করে।

```js run
let str = "I love JavaScript";
let regexp = /LOVE/i;

alert( regexp.test(str) ); // true
```

পরবর্তী অধ্যায়গুলোতে রেগুলার এক্সপ্রেশন সম্পর্কে আমরা আরো অনেক কিছু শিখব, আরো অনেক উদাহরণ এবং রেগুলার এক্সপ্রেশনের অন্যান্য মেথডগুলোও জানব।

মেথডগুলো সম্পর্কে বিস্তারিত আমরা এই অধ্যায়ে জানব <info:regexp-methods>.

## সারাংশ

- রেগুলার এক্সপ্রেশন গঠিত হয় প্যাটার্ন এবং অপশনাল ফ্ল্যাগের সমন্বয়েঃ `pattern:g`, `pattern:i`, `pattern:m`, `pattern:u`, `pattern:s`, `pattern:y`।
- ফ্ল্যাগ এবং স্পেশাল সিম্বল ছাড়া (পরবর্তীতে জানব) regexp এর সার্চ substring সার্চ এর মত কাজ করে.
- `str.match(regexp)` মেথডটি `pattern:g` ফ্ল্যাগের জন্য প্যাটার্নের সাথে সকল মিল খুঁজে, অন্যথায় শুধু প্রথম মিলটি খুঁজে। 
- `str.replace(regexp, replacement)` মেথডটি `regexp` দ্বারা প্রাপ্ত সব মিলকে `replacement` করে `pattern:g` ফ্ল্যাগের জন্য, অন্যথায় শুধু প্রথম মিলটিকে রিপ্লেস করে। 
- `regexp.test(str)` মেথডটি অন্তত একটি মিল খুঁজে পেলে `true` রিটার্ন করে, অন্যথায় `false` রিটার্ন করে।
